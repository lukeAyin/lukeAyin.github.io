某系统的进程可能占有和等待一些资源，现给出在某一时刻dump的这些进程占有和等待的资源信息，请按照如下简化规则分析哪些进程发生了死锁，请**升序**返回所有死锁的进程ID列表，或空列表 []。
 简化规则如下：

l 如果某个进程 *P* 的**任一**等待资源被占有，则该进程必须等待，直到这些资源被释放； 等待期间，该进程不会释放所占有的资源。

l 如果进程 *P* 所等待的资源全部都未被其他进程占有，则该进程**必将**释放所占有的资源。

基于上，如果某个进程因为所等待的资源一直被占有而无限等待下去，则认为该进程发生了死锁。

**输入**

第一行为一个整数num，表示进程个数；
 第二行开始的num行，依次表示每个进程占有和等待资源的情况，格式为：`进程``ID (``占有资源列表``) (``等待资源列表``)`。

0 <= 进程ID <= 100, 0 <= 资源编号 <= 300
 每一行的输入中不会包含重复的资源编号

输入保证：每个资源最多**只会**被一个进程占有。

**输出**

升序返回所有死锁的进程ID列表，或空列表 []

**样例****1**

输入：

> 5
>
> 100 () (20)
>
> 1 (40 20) (10)
>
> 2 (10) (30 100)
>
> 3 (100 300) (40 0)
>
> 0 () (30)

输出：

> [1 2 3 100]

解释：

·     进程1 等待被进程2 占有的资源10；进程2 等待被进程3 占有的资源100；进程3 等待被进程1 占有的资源40。这三个进程，都因为所等待的资源一直被占有而无限等待下去，所以这三个进程都发生了死锁。

·     因为进程1 死锁，资源20 一直被占有，导致进程100 也死锁。

·     进程0 等待的资源30 未被占有，因此进程0 不死锁。

**样例****2**

输入：

> 4
>
> 2 () (40 30)
>
> 1 (20) (30 40)
>
> 3 () ()
>
> 9 (40) (30)

输出：

> []

解释：

对于每个进程，其所等待的资源全部都未被其他进程占有，不死锁。
